# Bertrand 言語仕様

# 純粋関数型プログラミング

Bertrand は遅延評価を行う純粋型関数型言語である．
シンプルなラムダ計算をベースとする．


## 定数・変数

英小文字3文字以下またはvar宣言された識別子は変数とみなされる．それ以外またはcons宣言された識別子，定数に束縛された変数は定数となる．

    a              -- 変数
    just           -- 定数
    var true false -- 変数
    cons foo       -- 定数
    one = 1        -- 定数

変数は制約を持つことができる（後述）．

ラムダ抽象でない定数は，関数適用でそれ以上簡約されないデータコンストラクタとして用いることができる．
定数はグローバルスコープである（環境が異なっていても同じ名前なら同値）．


## 関数

    (id) (arg)* = (expr)

引数を持つ関数を束縛する．
関数が多重に定義されている場合，パターンマッチにより**最も具体的**な関数が適用される．

### ラムダ抽象

    \(arg)* -> (expr)

無名関数．

## 環境

定数束縛および変数制約（後述）は環境に属する．環境はラムダ抽象式か宣言構文によって作られる．

    \(args)* -> (expr) -- ラムダ抽象
    (expr) ! (dec)    -- 宣言構文 expr内においてdecが真である


### クロージャ

内側の環境は外側の環境を引き継ぐ．式は環境を保持する．


## 遅延評価

Bertrand は非正格な評価戦略をとる．評価は，

- ラムダ抽象
- 定数およびデータコンストラクタ
- プリミティブ値

のいずれかまで行われる．

パターンマッチでは，左辺は無条件に 右辺は左辺値とマッチするデータコンストラクタの場合に最低限評価される．
型検査中では，式の評価の有無や順序は保証されない．

## 構文

### case式

    case (expr) of ( (pattarn) -> (expr); )*

パターンマッチングを行う．多重定義された関数に対する適用に変換される（順序によらず，最も具体的なパターンが評価されることになる）．

    case x of nothing -> false; just _ -> true
    ↓
    f x ! f nothing = false; f (just _) = true

### if式

    if c then t else f

    #if true  x _ = x
    #if false _ y = y

### 演算子

演算子はユーザー定義することができ，結合順を設定できる．

    infix  (順位) (演算子) -- 無結合
    infixl (順位) (演算子) -- 左結合
    infixr (順位) (演算子) -- 右結合
    infixf (順位) (演算子) -- 述語結合（例：x > y > z  ->  x > y and y > z ）

    順位は整数で，数が大きいほど優先的に結合する．

# 論理型プログラミング

Bertrand はパターンマッチングと型検査を通して，論理式や推論を効果的に扱うことができる．

Bertrand の推論システムは，Prologのように事実と値の双方向の導出はできない（値aが述語Pを満たすか判定することはできるが，述語Pを満たす値を列挙することはできない）．推論をパターンマッチに限定することで，実用的な時間での推論や関数型パラダイムとの共存を図っている．

## 制約

    (dec)          -- 宣言文
    (var)* . (dec) -- 制約文

宣言文は，その式が環境内で真であることの宣言となる．
`変数.宣言` は宣言が特に変数に関する制約であることを示す．制約文内の宣言は，対象の変数のみパターンマッチ時に定数として扱われる．


## パターンマッチ

パターンマッチングは関数適用時と推論時に行われ，必要に応じて式を評価する．パターンマッチの試行は1つの環境を共有する．

### 定数パターン

    2 == 2
    just 2 == just 2

Aが定数のとき Bが同じ定数のときマッチする．

Aがデータコンストラクタのとき Bが同じデータコンストラクタかつフィールドが各々マッチしたときマッチする．


### 変数パターン

    true. true
    T

    true == T

Aが変数のとき Aが持つ制約をB（変数・定数）が全て満たすときマッチする．
Aについての制約をBが満たすとは，宣言式内のAをBに置き換えた式が真と推論されることである．

変数Aが式Bにマッチすると，環境においてAはBに束縛される．すなわち同じ変数が複数現れたとき，それらが全て同じ値をとるときマッチが成功する．

    pair a b == pair 1 2  -- a = 1, b = 2 にマッチ
    pair a a /= pair 1 2  -- a = 1, a /= 2 よりマッチせず


### ワイルドカードパターン

    _ == x
    _x == 1

    pair _a _a == pair 1 2

アンダースコア一文字の変数はワイルドカードとしてどんな式にもマッチし．束縛されない．

変数名がアンダースコアから始まるとき，それ以降の識別子の変数としてマッチを試行するが束縛はされない．


## 推論

式Aが真であるとは，式Aに相当する式Bが宣言されていることである．

### 論理演算

基本的な論理演算は標準で定義されている．

    A  -- Aは真
    ~B -- Bは偽
    A => C -- AならばC

    ~A      --> 偽
    ~B      --> 真
    A and B --> 偽
    A or B  --> 真
    C       --> 真


## 静的検査

静的型付け言語における型検査の役割を担う．

### 部分関数検出

関数に与えられうる引数の範囲が全て定義されているか？


### パラドクス検出

宣言文が相互に矛盾していないか？
